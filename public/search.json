[{"title":"metamask源码解析(一)","url":"/parse_metamask_1/","content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>MetaMask是最受欢迎的钱包之一, 是进入Web3世界的标志性工具，最重要是完全开源。</p>\n<blockquote>\n<p>ps: 对于开发者来说就是一款浏览器插件</p>\n</blockquote>\n<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><p>开始之前先需具备的知识点:</p>\n<ul>\n<li>chrome插件开发</li>\n<li>metamask的其他库基础库<ul>\n<li>stream相关的库:<ul>\n<li><a href=\"/parse_object_multiplex\">@metamask&#x2F;object-multiplex</a></li>\n<li>@metamask&#x2F;post-message-stream</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["技术"],"tags":["chrome-extension","web3","metamask"]},{"title":"理解@metamask/object-multiplex包","url":"/parse_object_multiplex/","content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL29iamVjdC1tdWx0aXBsZXg=\">@metamask&#x2F;object-multiplex<i class=\"fa fa-external-link-alt\"></i></span> 是 MetaMask 提供的一个基于<code>objectMode</code>的流多路复用库.</p>\n<p>用于将<strong>多条流整合到同一个流中处理</strong>，在<strong>同一个流中同时处理多种不同类型的数据通道</strong>（即多路复用）。</p>\n<p><code>ObjectMultiplex</code>继承于<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9yZWFkYWJsZS1zdHJlYW0=\">readable-stream<i class=\"fa fa-external-link-alt\"></i></span><sup id=\"fnref:1\"><a href=\"#fn:1\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"readable-stream是Node.js官方出的库,旨在提供Streams模块的兼容性实现。允许开发者在不同的Node.js版本中使用一致的`StreamsAPI`，同时也为浏览器环境提供支持\n\">[1]</span></a></sup>的<code>Duplex</code></p>\n<h2 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h2><p>使用<code>ObjectMultiplex</code> 多个流同时经过一个处理流</p>\n<p>不使用<code>ObjectMultiplex</code>时:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> streamA = <span class=\"keyword\">new</span> <span class=\"title class_\">Duplex</span>(...)</span><br><span class=\"line\"><span class=\"keyword\">const</span> streamB = <span class=\"keyword\">new</span> <span class=\"title class_\">Duplex</span>(...)</span><br><span class=\"line\"><span class=\"keyword\">const</span> transformStream = <span class=\"keyword\">new</span> <span class=\"title class_\">Transform</span>(...)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此时需分别添加transformStream</span></span><br><span class=\"line\">streamA.<span class=\"title function_\">pipe</span>(transformStream).<span class=\"title function_\">pipe</span>(streamA)</span><br><span class=\"line\">streamB.<span class=\"title function_\">pipe</span>(transformStream).<span class=\"title function_\">pipe</span>(streamB)</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>ObjectMultiplex</code>时, 注意transformStream需开启objectMode(因为ObjectMultiplex使用对象形式传输数据)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Transform</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;readable-stream&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ObjectMultiplex</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@metamask/object-multiplex&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mux = <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMultiplex</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> streamA = mux.<span class=\"title function_\">createStream</span>(<span class=\"string\">&#x27;streamA&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> streamB = mux.<span class=\"title function_\">createStream</span>(<span class=\"string\">&#x27;streamB&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transformStream = <span class=\"keyword\">new</span> <span class=\"title class_\">Transform</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// !! 注意必须objectMode: true, object-multiplex内部是使用对象形式传输的</span></span><br><span class=\"line\">  <span class=\"attr\">objectMode</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"title function_\">transform</span>(<span class=\"params\">chunk, encoding, callback</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;transform: &#x27;</span>, chunk);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">push</span>(chunk);</span><br><span class=\"line\">    <span class=\"title function_\">callback</span>();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此时只需直接往mux父流 添加 transformStream</span></span><br><span class=\"line\">mux.<span class=\"title function_\">pipe</span>(transformStream).<span class=\"title function_\">pipe</span>(mux);</span><br><span class=\"line\"></span><br><span class=\"line\">streamA.<span class=\"title function_\">write</span>(<span class=\"string\">&#x27;streamA test&#x27;</span>);</span><br><span class=\"line\">streamB.<span class=\"title function_\">write</span>(<span class=\"string\">&#x27;streamB test&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此时transformStream 接收到数据 为</span></span><br><span class=\"line\"><span class=\"comment\">// transform:  &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   name: &quot;streamA&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">//   data: &quot;streamA test&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// transform:  &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   name: &quot;streamB&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">//   data: &quot;streamB test&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"头尾同一流的意义\"><a href=\"#头尾同一流的意义\" class=\"headerlink\" title=\"头尾同一流的意义\"></a>头尾同一流的意义</h2><p>metamask出现很多头尾同一流</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">mux.<span class=\"title function_\">pipe</span>(streamA).<span class=\"title function_\">pipe</span>(mux)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>mux.pipe(streamA): 将 mux 的输出（分发后的数据）发送到 streamA</li>\n<li>streamA.pipe(mux): 将 streamA 的输入（通道的数据）发送回 mux, 让 mux 收集并分发。</li>\n</ul>\n<p>mux 需要从 streamA 中收集数据，同时将数据发送给 streamA。这构成了一个完整的循环</p>\n<p>实现了双向通信: 需要既发送又接收数据，形成完整的通信链路</p>\n<h3 id=\"双向通信\"><a href=\"#双向通信\" class=\"headerlink\" title=\"双向通信\"></a>双向通信</h3><p>streamA流和transformStream流可以相互通信</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Transform</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;readable-stream&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ObjectMultiplex</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@metamask/object-multiplex&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mux = <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMultiplex</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> streamA = mux.<span class=\"title function_\">createStream</span>(<span class=\"string\">&#x27;streamA&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transformStream = <span class=\"keyword\">new</span> <span class=\"title class_\">Transform</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// !! 注意必须objectMode: true, object-multiplex内部是使用对象形式传输的</span></span><br><span class=\"line\">  <span class=\"attr\">objectMode</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"title function_\">transform</span>(<span class=\"params\">chunk, encoding, callback</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;transform: &#x27;</span>, chunk);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">push</span>(chunk);</span><br><span class=\"line\">    <span class=\"title function_\">callback</span>();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此时只需直接往mux父流 添加 transformStream</span></span><br><span class=\"line\">mux.<span class=\"title function_\">pipe</span>(transformStream).<span class=\"title function_\">pipe</span>(mux);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>streamA 或mux 写入数据 传给 transform流</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mux.pipe(transformStream).pipe(mux)</span></span><br><span class=\"line\">streamA.<span class=\"title function_\">write</span>(<span class=\"string\">&#x27;streamA test&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 结果:</span></span><br><span class=\"line\"><span class=\"comment\">// transform:  &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   name: &quot;streamA&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">//   data: &quot;streamA test&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>数据流向大概是:</p>\n<ol>\n<li>streamA的<code>_write</code>触发, 内部调用<code>this._parent.push</code>(即是mux的push函数)</li>\n<li>mux的_read触发</li>\n<li>因pipe连接mux的可读流数据 触发transformStream的transform, transform内触发this.push</li>\n<li>因pipe连接transformStream的可读流数据 触发mux的_write</li>\n<li>mux的_write 即而触发 streamA的 _read</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此时需改成以streamA 连接，因为mux.write是往streamA的可读流添加数据</span></span><br><span class=\"line\">streamA.<span class=\"title function_\">pipe</span>(transformStream).<span class=\"title function_\">pipe</span>(streamA);</span><br><span class=\"line\">mux.<span class=\"title function_\">write</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;streamA&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">data</span>: <span class=\"string\">&#x27;mux stream call streamA&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 结果:</span></span><br><span class=\"line\"><span class=\"comment\">// transform:  mux stream call streamA</span></span><br></pre></td></tr></table></figure>\n\n<p>数据流向大概是:</p>\n<ol>\n<li>mux的<code>_write</code>触发， 内部substreams[&#39;streamA&#39;] 触发streamA的push函数</li>\n<li>streamA的_read触发</li>\n<li>因pipe连接streamA的可读流数据 触发transformStream的transform, transform内触发this.push</li>\n<li>因pipe连接transformStream的可读流数据 触发streamA的_write</li>\n<li>streamA的_write 即而触发streamA的<code>_parent</code>(即是mux)的push函数,  即而触发 mux的 _read</li>\n</ol>\n<p>transform流 写入数据 传给 streamA</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mux.pipe(transformStream).pipe(mux)</span></span><br><span class=\"line\"></span><br><span class=\"line\">transformStream.<span class=\"title function_\">write</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>:<span class=\"string\">&#x27;streamA&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">data</span>: <span class=\"string\">&#x27;transformStream test&#x27;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 注意这里 不能使用mux.on(&#x27;data&#x27;, ...)</span></span><br><span class=\"line\"><span class=\"comment\">// ObjectMultiplex 内部实现 mux 是parent流 不存储任何数据</span></span><br><span class=\"line\"><span class=\"comment\">// 所有数据都是由各子的子流substream 中存储</span></span><br><span class=\"line\"><span class=\"comment\">// 所以这里如果 mux.on(&#x27;data&#x27;, ...) 是永远都不会触发的</span></span><br><span class=\"line\">streamA.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;streamA data event:&#x27;</span>, data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结果:</span></span><br><span class=\"line\"><span class=\"comment\">// transform:  &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   name: &quot;streamA&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">//   data: &quot;transformStream test&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// streamA data event: transformStream test</span></span><br></pre></td></tr></table></figure>\n\n<p>数据流向大概是:</p>\n<ol>\n<li>transformStream的transform触发，transform内触发this.push</li>\n<li>因pipe连接mux流，transformStream的可读流数据 触发mux流的_write</li>\n<li>mux流的write触发 内部substreams[&#39;streamA&#39;] 触发streamA的push函数</li>\n<li>继而 streamA的_read触发</li>\n</ol>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p><img src=\"/images/parse_object_multiplex/1.png\" alt=\"1\" loading=\"lazy\"></p>\n<div id=\"footnotes\"><hr><div id=\"footnotelist\"><ol style=\"list-style: none; padding-left: 0; margin-left: 40px\"><li id=\"fn:1\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">1.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">readable-stream是Node.js官方出的库,旨在提供Streams模块的兼容性实现。允许开发者在不同的Node.js版本中使用一致的<code>StreamsAPI</code>，同时也为浏览器环境提供支持<a href=\"#fnref:1\" rev=\"footnote\"> ↩</a></span></li></ol></div></div>","categories":["技术"],"tags":["chrome-extension","web3","metamask"]},{"title":"理解@metamask/post-message-stream包","url":"/parse_post_message_stream/","content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\">","categories":["技术"],"tags":["chrome-extension","web3","metamask","npm-package"]},{"title":"分类","url":"/categories/index.html","content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\">"},{"title":"标签","url":"/tags/index.html","content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\">"},{"title":"404 Page Not Found","url":"//404.html","content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>404</p>\n"}]